/*
 * Skoop Search logic
 */
var Skoop = require('skoop'),
    searchFields = require('searchfields');

/*
 * Constructor
 *
 * @param db: SkoopDb object
 * @param criterion: Array of search criteria
 */
var Search = function(db, criterion) {
	this.db = db;

   this.sort = criterion.sort;
   this.limit = criterion.limit;
   this.options = {};

	if (this.sort)
		this.options['sort'] = this.sort;

	if (this.limit)
		this.options['limit'] = this.limit;

	this.searchFields = new searchFields.SearchFields("mongo");
	var skoop = new Skoop.Skoop(1, {});
	this._skoopKeys = Object.keys(skoop);
   this.query = {};
   buildQuery(this, criterion);
}

/*
 * execute
 * Executes the search and returns an array of matching skoops
 */
Search.prototype.execute = function(callback) {
	this.db.fetch(this.query, this.options, callback);
}

/*
 * Helper functions
 */
function buildQuery (self, criterion) {
	if (!criterion)
		return;

	// determine how the criteria are combined
	var conj = criterion['conjunction'] != null ? criterion['conjunction'] : "and";
	conj = self.searchFields.conjunctions[conj];
	self.query[conj] = [];

	// parse the criteria
	var keys = Object.keys(criterion);

	for (var i = 0; i < keys.length; i++) {
		var key = keys[i];
		var obj = null;

		if (key === 'criteria')
			obj = parseCriteria(self, criterion[key]);
		else
			obj = parseSkoopProperties(self, key, criterion[key]);

		if (obj)
			self.query[conj].push(obj);
	}

	if (self.query[conj].length === 0)
		self.query = {};
	else if (self.query[conj].length === 1)
		self.query = self.query[conj][0];
}

function parseCriteria (self, criteria) {
	var op = criteria.op;
	var values = criteria.values;
	var field = criteria.field;
	var fields = criteria.fields;
	var subQuery = {};

	if (!op || !values || !(field || fields))
		throw "Search criteria must contain { field|fields, op, values }";

	if (field) {
		// TODO: really? needs keywords array or keywords collection with skoop ids
		if (field === "text") {
			fields = [];
			fields.push("label");
			fields.push("url");
			fields.push("product");
			fields.push("category");
			fields.push("vendor");
			fields.push("tags");
		} else
			fields = [ field ];
	}

	if (fields.length > 1)
		subQuery = [];

	for (var i = 0; i < fields.length; i++) {
		field = fields[i];
		var map = self.searchFields.operators[op];
		var tokens = map.split(":");
		var obj = null;
		var prop = null;

		for (var j = 0; j < tokens.length; j++) {
			if (tokens[j] === self.searchFields.value) {
				if (prop === "$regex")
					obj[prop] = new RegExp("^" + values[0], "i");
				else
					obj[prop] = values[0];
			} else if (tokens[j] === self.searchFields.valArray)
				obj[prop] = values;
			else {
				if (obj) {
					obj[prop] = {};
					obj = obj[prop];
				} else {
					obj = {};

					if (Array.isArray(subQuery))
						subQuery.push(obj);
					else
						subQuery = obj;

				}

				if (tokens[j] === self.searchFields.field)
					prop = field;
				else
					prop = tokens[j];

				obj[prop] = null;
			}
		}
	}

	if (Array.isArray(subQuery)) {
		var conj = self.searchFields.conjunctions['or'];
		var qArray = subQuery;
		subQuery = {};
		subQuery[conj] = qArray;
	}

	return subQuery;
}

function parseSkoopProperties (self, prop, value) {
	var subQuery = null;

	for (var i = 0; i < self._skoopKeys.length; i++) {
		if (prop === self._skoopKeys[i]) {
			subQuery = {};

			var skoop = new Skoop.Skoop(1, {});
			var dataType = skoop.dataType(prop);
			var data = value;

			if (dataType === "date")
				data = new Date(value).getTime();
			else if (dataType === "float")
				data = parseFloat(value);

			subQuery[prop] = data;
			break;
		}
	}

	return subQuery;
}

exports.Search = Search;
