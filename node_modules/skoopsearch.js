/*
 * Skoop Search logic
 */
var Skoop = require('skoop'),
    searchFields = require('searchfields');

/*
 * Constructor
 *
 * @param db: SkoopDb object
 * @param criterion: Array of search criteria
 */
var Search = function(db, criterion) {
	this.db = db;

   this.sort = criterion.sort;
   this.limit = criterion.limit;
   this.options = {};

	if (this.sort)
		this.options['sort'] = this.sort;

	if (this.limit)
		this.options['limit'] = this.limit;

	this.searchFields = new searchFields.SearchFields("mongo");
	var skoop = new Skoop.Skoop(1, {});
	this._skoopKeys = Object.keys(skoop);
   this.query = {};
   parseCriterion(this, criterion);
}

/*
 * execute
 * Executes the search and returns an array of matching skoops
 */
Search.prototype.execute = function(callback) {
	this.db.fetch(this.query, this.options, callback);
}

function parseCriterion(self, criterion) {
	var keys = Object.keys(criterion);
	var conj = criterion['conjunction'] == null ? criterion['conjunction'] : "and";

	for (var i = 0; i < keys.length; i++) {
		var key = keys[i];
		var obj = null;

		if (key === 'criteria')
			obj = parseCriteria(self, criterion[key]);
		else
			obj = parseSkoopProperties(self, key, criterion[key]);

		// must build nested object here. with mongo keywords
		// need to encapsulate the keywords in case we search something besides mongo
		self.query = obj;
	}
}

function parseCriteria (self, criteria) {
	var op = criteria.op;
	var values = criteria.values;
	var field = criteria.field;
	var subQuery = {};

	if (field) {
		var map = self.searchFields.mapping[op];
		var tokens = map.split(":");
		var obj = null;
		var prop = null;

		for (var i = 0; i < tokens.length; i++) {
			if (tokens[i] === self.searchFields.value)
				obj[prop] = values[0];
			else if (tokens[i] === self.searchFields.valArray)
				obj[prop] = values;
			else {
				if (obj) {
					obj[prop] = {};
					obj = obj[prop];
				} else {
					obj = {};
					subQuery = obj;
				}

				if (tokens[i] === self.searchFields.field)
					prop = field;
				else
					prop = tokens[i];

				obj[prop] = null;
			}
		}
	} else if (criteria.fields) {
	}

	return subQuery;
}

function parseSkoopProperties (self, prop, value) {
	var subQuery = {};

	for (var i = 0; i < self._skoopKeys.length; i++) {
		if (prop === self._skoopKeys[i]) {
			subQuery[prop] = value;
			break;
		}
	}

	return subQuery;
}

exports.Search = Search;
