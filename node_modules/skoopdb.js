var mongo = require('mongodb'),
  EventEmitter = require('events').EventEmitter,
  inherits = require('util').inherits,
  crypto = require('crypto'),
  debug = require('util').debug,
  inspect = require('util').inspect,
  fs = require('fs'),
  path = require('path'),
  Skoop = require('skoop');

var Db = mongo.Db,
	Connection = mongo.Connection,
	Server = mongo.Server,
	BSON = mongo.BSONPure,
	GridStore = mongo.GridStore;

var _defHost = process.env['MONGO_NODE_DRIVER_HOST'] != null ? process.env['MONGO_NODE_DRIVER_HOST'] : 'localhost';
var _defPort = process.env['MONGO_NODE_DRIVER_PORT'] != null ? process.env['MONGO_NODE_DRIVER_PORT'] : Connection.DEFAULT_PORT;

/*
 * constructor
 * @param host The database host
 * @param port The port the host listens on
 * @param options[] An array of configuration options
 */
var SkoopDb = function (host, port, options) {
	EventEmitter.call(this);
	this.host = host == null ? _defHost : host;
	this.port = port == null ? _defPort : port;
	this.options = options == null ? {} : options;
	this.error = null;
	this.db = new Db('skoopdb', new Server(this.host, this.port, {'auto_reconnect': true, 'poolSize': 4}), {});

	this.db.open(function (err, db) {
		if (err) {
			this.error = err;
			return;
		}
	});
};

inherits(SkoopDb, EventEmitter);

/*
 * Validate the db can be opened and all required objects exists.
 * Returns true/false
 * Unused
 */
SkoopDb.prototype.validateDb = function() {
	this.db.createCollection('skoops', {'safe':false}, function(err, collection) {
		if (err != null)
			throw new Error("Unable to create the skoops collection: " + err);
	});
};

SkoopDb.prototype.close = function() {
	db.close();
};

/**
 * Returns all matches
 * @param {} query a list of Skoop fields to use in the query
 * @param {} options list of query options (sort, limit, skip, ...)
 * @param () callback returns skoops or error
 */
SkoopDb.prototype.fetch = function(query, options, callback) {
	var self = this;
	options = options != null ? options : {};

	if (query._id)
		query._id = new BSON.ObjectID(query._id);

	//db.strict = false;
	self.db.collection('skoops', {}, function(err, collection) {
		if (err != null)
			return callback(new Error("Error finding skoops collection: " + err), null);

		collection.find(query, options, function(err, cursor) {
			if (err == null) {
				var skoops = [], i = 0;

				cursor.each(function(err, doc) {
					// TODO: if invalid skoop emit error for invalid Skoop
					if (doc == null) {
						return callback(null, skoops);
					} else if ('user' in doc)
						skoops[i++] = new Skoop.Skoop(doc['user'], doc);
				});
			} else
				return callback(err, null);
		});
	});
};

/*
 * creates a skoop
 * @param user: identifier for a user
 * @param {Object} properties properties of a skoop (optional)
 * @param {Function} callback (optional)
 * returns skoop in callback
 */
SkoopDb.prototype.create = function(user, properties, callback) {
	var self = this;

	if (properties != null && properties._id)
		return callback(new Error("The skoop " + properties.id + " already exists."), null);

	var skoop = new Skoop.Skoop(user, properties);

	if (!skoop.valid) {
		var msg = "Invalid skoop: " + skoop.error;
		this.emit('error', msg);

		if (typeof callback === 'function')
			return callback("Invalid skoop: " + skoop.error, null);
		else
			return;
	}

	// insert skoop
	this.db.collection('skoops', {}, function(err, collection) {
		var skoops;

		if (err != null)
			return callback(new Error("Error finding skoops collection: " + err), null);

		skoops = collection;
		skoops.insert(skoop, function(err, skoop) {
				if (err) {
					self.error = err;
					self.emit('error', err);
				} else
					self.emit('created', skoop);
		});

		if ('function' === typeof callback) {
			if (this.error)
				return callback(error, null);
			else
				return callback(null, skoop);
		} else
			return;
	});
};

/*
 * Updates using skoop._id
 * @param {} selector Contains the fields identifying the object(s) to update
 * @param {} attributes Contains the attributes to be updated
 * @param {Function} callback returns error (optional)
 */
SkoopDb.prototype.update = function(selector, attributes, callback) {
	var self = this;

	if (selector._id)
		selector = { '_id' : new BSON.ObjectID(selector._id) };

	this.db.collection('skoops', {}, function(err, collection) {
		var skoops;

		if (err != null)
			return callback(new Error("Error finding skoops collection: " + err), null);

		skoops = collection;
		// update the timestamp and add the $set operator to only update the specified fields
		attributes.updated = new Date().getTime();
		var pushMems = null;
		var pullMems = null;

		if (attributes.addmembers) {
			pushMems = parseMembers('push', attributes.addmembers);
			delete attributes.addmembers;
		}

		if (attributes.removemembers) {
			pullMems = parseMembers('pull', attributes.removemembers);
			delete attributes.removemembers;
		}

		var updAttrs = { $set : attributes };

		if (pushMems)
			updAttrs[pushMems['op']] = pushMems['data'];

		if (pullMems)
			updAttrs[pullMems['op']] = pullMems['data'];

		skoops.update(selector, updAttrs, function(err) {
			if (err) {
				self.error = err;
				self.emit('error', err);
			} else
				self.emit('updated');
		});

		return callback(null);
	});
};

/*
 * removes a skoop using the skoop._id
 * @param {} fields list of fields used to delete skoops
 * @param {Function} callback returns error (optional)
 */
SkoopDb.prototype.remove = function(fields, callback) {
	var self = this;

	if ('_id' in fields)
		fields['_id'] = new BSON.ObjectID(fields._id);

	this.db.collection('skoops', {}, function(err, collection) {
		var skoops;

		if (err != null)
			return callback(new Error("Error finding skoops collection: " + err), null);

		skoops = collection;
		skoops.remove(fields, {}, function(err) {
			if (err) {
				self.error = err;
				self.emit('error', err);
				return callback(err);
			} else {
				self.emit('removed');
				return callback();
			}
		});
	});
};

/*
 * Add an image for a Skoop
 * @param skoopId - The _id of the skoop
 * @param file - The name of the file
 * @param @callback - called with an error message and null and the _id of the image
 */
SkoopDb.prototype.addImage = function(skoopId, file, callback) {
	var self = this;
	var _id = new BSON.ObjectID(skoopId);
	// TODO: should check for skoop existing first
	var ext = path.extname(file);

	fs.readFile(file, 'binary', function(err, data) {
		if (err != null)
			return callback(err, null);

		var gridStore = new GridStore(self.db, skoopId, "w");
		gridStore.open(function(err, gridStore) {
			if (err)
				return callback(err, null);

			gridStore.metadata = {'ext' : ext };
			gridStore.write(data, function(err, gridStore) {
				if (err) {
					self.error = err;
					self.emit('error', err);
				}

				gridStore.close(function(err, result) {
					if (err != null)
						return callback(err, null);
					else
						return callback(null, result._id);
				});
			});
		});
	});
};

/*
 * Get an image for a Skoop
 * @param skoopId - The _id of the skoop
 * @param @callback - called with an error message and the data for the file and the extension
 */
SkoopDb.prototype.getImage = function(skoopId, callback) {
	var self = this;
	var _id = new BSON.ObjectID(skoopId);
	// TODO: should check for skoop existing first

	var gridStore = new GridStore(this.db, skoopId, "r");
	gridStore.open(function(err, gridStore) {
		if (err)
			return callback(err, null);

		if (!gridStore.metadata)
			return callback(new Error("No image found for skoop: " + skoopId.toString()), null);

		var ext = gridStore.metadata['ext'];
		gridStore.read(function(err, data) {
			if (err) {
				self.error = err;
				self.emit('error', err);
			}

			gridStore.close(function(err) {
				if (err != null)
					return callback(err, null);
				else
					return callback(null, data, ext);
			});
		});
	});
};

/*
 * Helpers
 */

 // this could become a parse array attribute
function parseMembers(action, members) {
	if (!members || !(typeof members === 'object'))
		return attributes;

	var values = [];
	var retVal = [];

	if (action === 'push') {
		for (var i = 0; i < members.length; i++)
			values.push(members[i]);
	} else if (action === 'pull') {
		for (var i = 0; i < members.length; i++)
			values.push(members[i]);
	}

	if (values.length === 0)
		retVal = undefined;
	else if (action === 'push') {
		retVal = { op : '$addToSet',  data : { members : { $each : values } } };
	} else {
		retVal = { op : '$pullAll', data : { members : values } };
	}

	return retVal;
}

// export the object
exports.SkoopDb = SkoopDb;
