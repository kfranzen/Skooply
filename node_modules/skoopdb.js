var mongo = require('mongodb'),
  EventEmitter = require('events').EventEmitter,
  inherits = require('util').inherits,
  crypto = require('crypto'),
  debug = require('util').debug,
  inspect = require('util').inspect,
  fs = require('fs'),
  path = require('path'),
  Skoop = require('skoop');

var Db = mongo.Db,
	Connection = mongo.Connection,
	Server = mongo.Server,
	BSON = mongo.BSONPure,
	GridStore = mongo.GridStore;

var _defHost = process.env['MONGO_NODE_DRIVER_HOST'] != null ? process.env['MONGO_NODE_DRIVER_HOST'] : 'localhost';
var _defPort = process.env['MONGO_NODE_DRIVER_PORT'] != null ? process.env['MONGO_NODE_DRIVER_PORT'] : Connection.DEFAULT_PORT;

/*
 * constructor
 * @param host The database host
 * @param port The port the host listens on
 * @param options[] An array of configuration options
 */
var SkoopDb = function (host, port, options) {
	EventEmitter.call(this);
	this.host = host == null ? _defHost : host;
	this.port = port == null ? _defPort : port;
	this.options = options == null ? {} : options;
	this.db = new Db('skoopdb', new Server(this.host, this.port, this.options), {});
	this.error = null;

  // Set up logger
  if (this.options.logger != null &&
  		(typeof this.options.logger.debug == 'function') &&
  		(typeof this.options.logger.error == 'function') &&
  		(typeof this.options.logger.log == 'function'))
		this.logger = this._options.logger;
   else
   	this.logger = {error:function(message, object) {}, log:function(message, object) {}, debug:function(message, object) {}};
};

inherits(SkoopDb, EventEmitter);

/*
 * Validate the db can be opened and all required objects exists.
 * Returns true/false
 * Unused
 */
SkoopDb.prototype.validateDb = function() {
	this.db.open(function(err, db) {
		if (err == null) {
			db.createCollection('skoops', {'safe':false}, function(err, collection) {
				if (err != null)
					throw new Error("Unable to create the skoops collection: " + err);
			});
		} else
			throw new Error("Could not connect to the database: " + err);
	});
};

/**
 * Returns all matches
 * @param {} query a list of Skoop fields to use in the query
 * @param {} options list of query options (sort, limit, skip, ...)
 * @param () callback returns skoops or error
 */
SkoopDb.prototype.fetch = function(query, options, callback) {
	var self = this;
	options = options != null ? options : {};

	if (query._id)
		query._id = new BSON.ObjectID(query._id);

	this.db.open(function(err, db) {
		if (err != null)
			return callback(err, null);

		//db.strict = false;
		db.collection('skoops', {}, function(err, collection) {
			if (err != null)
				return callback(new Error("Error finding skoops collection: " + err), null);

			collection.find(query, options, function(err, cursor) {
				if (err == null) {
					var skoops = [], i = 0;

					cursor.each(function(err, doc) {
						// TODO: if invalid skoop emit error for invalid Skoop
						if (doc == null) {
							db.close();
							return callback(null, skoops);
						} else if ('user' in doc)
							skoops[i++] = new Skoop.Skoop(doc['user'], doc);
					});
				} else
					return callback(err, null);
			});
		});
	});
};

/*
 * creates a skoop
 * @param user: identifier for a user
 * @param {Object} properties properties of a skoop (optional)
 * @param {Function} callback (optional)
 * returns skoop in callback
 */
SkoopDb.prototype.create = function(user, properties, callback) {
	var self = this;

	if (properties != null && properties._id)
		return callback(new Error("The skoop " + properties.id + " already exists."), null);

	var skoop = new Skoop.Skoop(user, properties);

	if (!skoop.valid) {
		var msg = "Invalid skoop: " + skoop.error;
		this.emit('error', msg);

		if (typeof callback === 'function')
			return callback("Invalid skoop: " + skoop.error, null);
		else
			return;
	}

	this.db.open(function(err, db) {
		if (err != null)
			return callback(err, null);

		//db.strict = false;
		// insert skoop
		db.collection('skoops', {}, function(err, collection) {
			var skoops;

			if (err == null)
				skoops = collection;
			else {
				db.createCollection('skoops', {}, function(err, collection) {
					if (err == null)
						skoops = collection;
					else
						return callback(new Error("Unable to create the skoops collection: " + err), null);
				});
			}

			skoops.insert(skoop, function(err, skoop) {
					if (err) {
						self.error = err;
						self.emit('error', err);
					} else
						self.emit('created', skoop);
			});

			db.close();

			if ('function' === typeof callback) {
				if (this.error)
					return callback(error, null);
				else
					return callback(null, skoop);
			} else
				return;
		});
	});
};

/*
 * Updates using skoop._id
 * @param {} selector Contains the fields identifying the object(s) to update
 * @param {} attributes Contains the attributes to be updated
 * @param {Function} callback returns error (optional)
 */
SkoopDb.prototype.update = function(selector, attributes, callback) {
	var self = this;

	if (selector._id)
		selector = { '_id' : new BSON.ObjectID(selector._id) };

	this.db.open(function(err, db) {
		if (err != null)
			return callback(err, null);

		//db.strict = false;
		db.collection('skoops', {}, function(err, collection) {
			var skoops;

			if (err == null)
				skoops = collection;
			else {
				db.createCollection('skoops', {}, function(err, collection) {
					if (err == null)
						skoops = collection;
					else
						return callback(new Error("Unable to create the skoops collection: " + err), null);
				});
			}

			// update the timestamp and add the $set operator to only update the specified fields
			attributes.updated = Date.now();
			var pushMems = null;
			var pullMems = null;

			if (attributes.addmembers) {
				pushMems = parseMembers('push', attributes.addmembers);
				delete attributes.addmembers;
			}

			if (attributes.removemembers) {
				pullMems = parseMembers('pull', attributes.removemembers);
				delete attributes.removemembers;
			}

			var updAttrs = { $set : attributes };

			if (pushMems)
				updAttrs[pushMems['op']] = pushMems['data'];

			if (pullMems)
				updAttrs[pullMems['op']] = pullMems['data'];

			skoops.update(selector, updAttrs, function(err) {
				if (err) {
					self.error = err;
					self.emit('error', err);
				} else
					self.emit('updated');
			});

			db.close();
			return callback(null);
		});
	});
};

/*
 * removes a skoop using the skoop._id
 * @param {} fields list of fields used to delete skoops
 * @param {Function} callback returns error (optional)
 */
SkoopDb.prototype.remove = function(fields, callback) {
	var self = this;

	if ('_id' in fields)
		fields['_id'] = new BSON.ObjectID(fields._id);

	this.db.open(function(err, db) {
		if (err != null)
			return callback(err, null);

		//db.strict = false;
		db.collection('skoops', {}, function(err, collection) {
			var skoops;

			if (err == null)
				skoops = collection;
			else {
				db.createCollection('skoops', {}, function(err, collection) {
					if (err == null)
						skoops = collection;
					else
						return callback(new Error("Unable to create the skoops collection: " + err), null);
				});
			}

			skoops.remove(fields, {}, function(err) {
				if (err) {
					self.error = err;
					self.emit('error', err);
					return callback(err);
				} else {
					self.emit('removed');
					return callback();
				}
			});
			db.close();
		});
	});
};

/*
 * Add an image for a Skoop
 * @param skoopId - The _id of the skoop
 * @param file - The name of the file
 * @param @callback - called with an error message and null and the _id of the image
 */
SkoopDb.prototype.addImage = function(skoopId, file, callback) {
	var self = this;
	var _id = new BSON.ObjectID(skoopId);
	// TODO: should check for skoop existing first
	var ext = path.extname(file);

	fs.readFile(file, 'binary', function(err, data) {
		if (err != null)
			return callback(err, null);

		self.db.open(function(err, db) {
			if (err != null)
				return callback(err, null);

			var gridStore = new GridStore(db, skoopId, "w");
			gridStore.open(function(err, gridStore) {
				if (err) {
					db.close();
					return callback(err, null);
				}

				gridStore.metadata = {'ext' : ext };
				gridStore.write(data, function(err, gridStore) {
					// TODO: need to handle write error
					gridStore.close(function(err, result) {
						db.close();

						if (err != null)
							return callback(err, null);
						else
							return callback(null, result._id);
					});
				});
			});
		});
	});
};

/*
 * Get an image for a Skoop
 * @param skoopId - The _id of the skoop
 * @param @callback - called with an error message and the data for the file and the extension
 */
SkoopDb.prototype.getImage = function(skoopId, callback) {
	var self = this;
	var _id = new BSON.ObjectID(skoopId);
	// TODO: should check for skoop existing first

	this.db.open(function(err, db) {
		if (err != null)
			return callback(err, null);

		var gridStore = new GridStore(db, skoopId, "r");
		gridStore.open(function(err, gridStore) {
			if (err) {
				db.close();
				return callback(err, null);
			}

			var ext = gridStore.metadata['ext'];
			gridStore.read(function(err, data) {
				// TODO: need to handle read error
				gridStore.close(function(err) {
					db.close();

					if (err != null)
						return callback(err, null);
					else
						return callback(null, data, ext);
				});
			});
		});
	});
};

/*
 * Helpers
 */

 // this could become a parse array attribute
function parseMembers(action, members) {
	if (!members || !(typeof members === 'object'))
		return attributes;

	var values = [];
	var retVal = [];

	if (action === 'push') {
		for (var i = 0; i < members.length; i++)
			values.push(members[i]);
	} else if (action === 'pull') {
		for (var i = 0; i < members.length; i++)
			values.push(members[i]);
	}

	if (values.length === 0)
		retVal = undefined;
	else if (action === 'push') {
		retVal = { op : '$addToSet',  data : { members : { $each : values } } };
	} else {
		retVal = { op : '$pullAll', data : { members : values } };
	}

	return retVal;
}

// export the object
exports.SkoopDb = SkoopDb;
